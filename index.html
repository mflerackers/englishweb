<html>
<header>
  <link href="https://fonts.googleapis.com/css?family=Kalam" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109740765-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    
    gtag('config', 'UA-109740765-2');
  </script>
  <style>
    body {
      width: 100%
    }
    div.word {
      display: inline-block;
      font-family: 'Kalam', cursive;
      font-size: 20vw;
    }
    div.container {
      text-align: center;
      width: 100%
    }
    div.word span {
      -webkit-text-stroke: 1.5px black;
    }
    #error {
      font-family: "Lato", "Lucida Grande", "Lucida Sans Unicode", "Tahoma", "Sans-Serif";
    }
  </style>
  <link rel="stylesheet" type="text/css" href="./colors.css/">
  <script src="./rita-full.min.js"/></script>
</header>
<body>
  <a href="./phoneme-quiz.html">Phoneme quiz</a>
  <center><input id="word" type="text" placeholder="Type here"></center>
  <div class="container">
    <div class="word" id="worddisplay"></div>
  </div>
  <center><span id="error" style="color:red"></span></center>
</body>
<script>
  function assert(condition, message) {
    if (!condition)
    throw message || "Assertion failed";
  }
  
  // Dynamic programming algorithm to match phonemes with graphemes
  class MatchCandidate {
    constructor(remaining, phonemes, graphemes, score) {
      this.remaining = remaining;
      this.phonemes = phonemes || [];
      this.graphemes = graphemes || [];
      this.score = score || 0;
    }
    extend(phoneme, grapheme) {
      let remaining = this.remaining.substring(grapheme.length)
      var phonemes = this.phonemes.slice()
      var graphemes = this.graphemes.slice()
      var score = this.score
      
      phonemes.push(phoneme)
      graphemes.push(grapheme)
      
      if (phoneme == "silent") 
      score = score - 2; // Silent grapheme
      else
      score = score + 1;
      
      score = score / this.remaining
      
      return new MatchCandidate(remaining, phonemes, graphemes, score)
    }
    match() {
      var match = [];
      for (let i = 0; i < this.phonemes.length; i++)
      match.push({ph:this.phonemes[i], ch:this.graphemes[i]});
      
      // Silent
      if (this.remaining.length > 0) {
        match.push({ph:"silent", ch:this.remaining});
        console.log("Chosen candidate " + this.graphemes + "," + this.remaining + " for " + this.phonemes + ",silent");
      }
      else
      console.log("Chosen candidate " + this.graphemes + " for " + this.phonemes);
      
      return match;
    }
  }
  
  letters = {
    AA : ["o", "aw", "ou", "a"],
    AE : ["a"],
    AH : ["ou", "u", "a", "e", "o", "oo", "i"],
    AO : ["oa", "aw", "ou", "oo", "o", "a"],
    AW : ["ou", "ow"],
    AY : ["ie", "uy", "ey", "i", "y"],
    B  : ["bb", "b"],
    CH : ["ch", "tch"],
    D  : ["dd", "d"],
    DH : ["th"],
    EH : ["ea", "e", "ai", "a"],
    ER : ["ear", "er", "ir", "or", "r"],
    EY : ["ay", "ai", "a", "ei", "ey", "e"],
    G  : ["gg", "g"],
    F  : ["ff", "f", "ph", "gh"],
    HH : ["h"],
    IH : ["ee", "e", "i", "ui"],
    IU : ["iew", "ue", "u"],
    IY : ["i", "y", "ee", "ea", "e"],
    JH : ["dge", "ge", "g", "j", "su"], // su added for ZH
    K  : ["ch", "ck", "c", "k", "q"],
    L  : ["ll", "l", "le"],
    M  : ["mm", "m"],
    N  : ["nn", "n"],
    NG : ["ng", "n"],
    OW : ["oa", "ou", "ow", "oe", "o"],
    OY : ["oi", "oy"],
    P  : ["pp", "p"],
    R  : ["rr", "r"],
    S  : ["c", "sc", "ss", "s"],
    SH : ["ch", "sh", "si", "ti"],
    T  : ["tt", "t"],
    TH : ["th"],
    UH : ["oo", "o", "u"],
    UL : ["ull"],
    UW : ["oo", "ou", "o", "u", "ue", "wo"],
    V  : ["v", "v", "f"],
    W  : ["u", "wh", "w"],
    X  : ["x", "cs", "ks"],
    Z  : ["zz", "z", "s"]
  };
  
  silents = ["ew", "e", "gh", "g", "h", "k", "w", "t"];
  
  function getSilent(graphemes) {
    //console.log("looking for silent in " + graphemes);
    for (silent of silents) {
      if (graphemes.startsWith(silent))
      return silent
    }
    return null;
  }
  
  function transformPhonemes(phonemes) {
    newPhonemes = [];
    let prev = null
    for (phoneme of phonemes) {
      if (phoneme == "Y") {
        if (prev)
        newPhonemes.push(prev);
        prev = "Y";
      }
      else if (prev == "Y") {
        prev = null
        if (phoneme == "UW")
        newPhonemes.push("IU");
        else {
          newPhonemes.push( "Y");
          newPhonemes.push(phoneme);
        }
      }
      else if (phoneme == "K") {
        if (prev)
        newPhonemes.push(prev);
        prev = "K";
      }
      else if (prev == "K") {
        prev = null;
        if (phoneme == "S")
        newPhonemes.push("X");
        else {
          newPhonemes.push("K");
          newPhonemes.push(phoneme);
        }
      }
      /*elseif phoneme == "UH" then
      tmp = "UH"
      elseif tmp == "UH" then
      tmp = nil
      if phoneme == "L" then
      table.insert(list, "UL")
      else
      table.insert(list, "UH")
      table.insert(list, phoneme)
      end*/
      else if (phoneme == "ZH")
      newPhonemes.push("JH");
      else
      newPhonemes.push(phoneme);
    }
    if (prev)
    newPhonemes.push(prev);
    
    return newPhonemes;
  }
  
  function matchPhonemes(word, phonemes) {
    var candidates = [new MatchCandidate(word)];
    for (phoneme of phonemes) {
      //console.log(phoneme);
      let graphemes = letters[phoneme];
      assert(graphemes, "No graphemes found for " + phoneme + " in " + phonemes);
      var newCandidates = [];
      for (let grapheme of graphemes) {
        //console.log(grapheme);
        for (let candidate of candidates) {
          //console.log(candidate);
          if (candidate.remaining.startsWith(grapheme)) {
            //console.log("added " + grapheme + " for " + phoneme);
            newCandidates.push(candidate.extend(phoneme, grapheme));
          }
          // Only match silents within a word
          if (candidate.remaining.length != word.length) {
            let silent = getSilent(candidate.remaining);
            if (silent && candidate.remaining.indexOf(grapheme) == silent.length) {
              //console.log("added silent " + silent + " before " + grapheme)
              let silentCandidate = candidate.extend("silent", silent);
              newCandidates.push(silentCandidate.extend(phoneme, grapheme));
            }
            else if (silent)
            ;//console.log("no match for " + silent + " and " + grapheme);
          }
        }
      }
      candidates = newCandidates;
    }
    assert(candidates.length > 0, "No candidates to match " + word + " with " + phonemes);
    let candidate = candidates.reduce(function(a, b) {
      return a.score > b.score ? a : b;
    });
    return candidate.match()
  }
  
  function refreshText(input) {
    let text = input.value.toLowerCase();
    
    document.getElementById("worddisplay").innerHTML = "";
    document.getElementById("error").innerText = "";
    
    if (text.length == 0)
    return;
    
    let phonemes = RiTa.getPhonemes(text).toUpperCase().split("-");
    phonemes = transformPhonemes(phonemes);
    
    console.log(phonemes);
    
    let result = null;
    try {
      result = matchPhonemes(text, phonemes);
    }
    catch (message) {
      document.getElementById("error").innerText = message;
      return;
    }
    
    console.log(result);
    
    let html = "";
    for (matches of result)
    html += "<span class='" + matches.ph + "'>" + matches.ch + "</span>";
    document.getElementById("worddisplay").innerHTML = html;
  }
  
  document.getElementById("word").oninput = function() {
    refreshText(this);
  }
  
  refreshText(document.getElementById("word"));
</script>
</html>
